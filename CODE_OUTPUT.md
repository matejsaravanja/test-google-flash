**This file consists of the entire unaltered output for reference.**

Okay, I understand. The user wants a React-based frontend added to the project, keeping the existing backend structure and logic intact. I will create the necessary React components and pages, along with configuration files, to provide a basic UI for interacting with the NFT marketplace.

Here's the complete code, incorporating the frontend and addressing some of the minor points raised in the previous explanations:

```json
{
  "craft-nft-marketplace/backend/app/__init__.py": "# craft-nft-marketplace/backend/app/__init__.py\n# You can initialize app-level variables or configurations here if needed.",
  "craft-nft-marketplace/backend/app/config.py": "# craft-nft-marketplace/backend/app/config.py\nimport os\n\nclass Settings:\n    SOLANA_NETWORK = os.getenv("SOLANA_NETWORK", "http://127.0.0.1:8899")  # Change this to devnet/mainnet-beta appropriately\n    CRAFT_MINT_ADDRESS = os.getenv("CRAFT_MINT_ADDRESS", "YOUR_CRAFT_MINT_ADDRESS")\n    APPLICATION_WALLET_PRIVATE_KEY = os.getenv("APPLICATION_WALLET_PRIVATE_KEY", "YOUR_APPLICATION_WALLET_PRIVATE_KEY")\n    TREASURY_WALLET_PUBLIC_KEY = os.getenv("TREASURY_WALLET_PUBLIC_KEY", "YOUR_TREASURY_WALLET_PUBLIC_KEY") #For collecting fees and revenue\n    EMAIL_HOST = os.getenv("EMAIL_HOST")\n    EMAIL_PORT = os.getenv("EMAIL_PORT", 587)\n    EMAIL_HOST_USER = os.getenv("EMAIL_HOST_USER")\n    EMAIL_HOST_PASSWORD = os.getenv("EMAIL_HOST_PASSWORD")\n    EMAIL_FROM_ADDRESS = os.getenv("EMAIL_FROM_ADDRESS")\n    MARKETPLACE_FEE = float(os.getenv("MARKETPLACE_FEE", 0.02)) # 2% Marketplace Fee\n\nsettings = Settings()",
  "craft-nft-marketplace/backend/app/utils.py": "# craft-nft-marketplace/backend/app/utils.py\nimport base64\nfrom solana.keypair import Keypair\nfrom solana.publickey import PublicKey\n\ndef generate_keypair():\n    """Generates a new Solana keypair."""\n    keypair = Keypair()\n    private_key_b64 = base64.b64encode(keypair.secret_key).decode(\'utf-8\')\n    public_key = str(keypair.pubkey())\n\n    return public_key, private_key_b64\n\ndef validate_public_key(public_key: str) -> bool:\n    """Validates if a string is a valid Solana public key."""\n    try:\n        PublicKey(public_key)\n        return True\n    except Exception:\n        return False",
  "craft-nft-marketplace/backend/app/security.py": "# craft-nft-marketplace/backend/app/security.py\nfrom passlib.context import CryptContext\nfrom jose import JWTError, jwt\nfrom datetime import datetime, timedelta\nimport os\n\nSECRET_KEY = os.getenv("SECRET_KEY", "YOUR_SECRET_KEY")  # Replace with a strong, random key\nALGORITHM = "HS256"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef hash_password(password: str):\n    return pwd_context.hash(password)\n\ndef verify_password(plain_password: str, hashed_password: str):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\ndef verify_token(token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        # Check for token expiration or other custom validation\n        return payload\n    except JWTError:\n        return None",
  "craft-nft-marketplace/backend/app/blockchain.py": "# craft-nft-marketplace/backend/app/blockchain.py\nfrom solana.rpc.api import Client\nfrom solana.keypair import Keypair\nfrom solana.publickey import PublicKey\nfrom solana.transaction import Transaction\nfrom spl.token.client import Token\nfrom spl.token import instructions as spl_token_instructions\nfrom spl.token.constants import TOKEN_PROGRAM_ID\nfrom .config import settings\nimport base64\n\n\nSOLANA_NETWORK = settings.SOLANA_NETWORK\nCRAFT_MINT_ADDRESS = settings.CRAFT_MINT_ADDRESS\nAPPLICATION_WALLET_PRIVATE_KEY = settings.APPLICATION_WALLET_PRIVATE_KEY\nTREASURY_WALLET_PUBLIC_KEY = settings.TREASURY_WALLET_PUBLIC_KEY\nMARKETPLACE_FEE = settings.MARKETPLACE_FEE\n\ndef transfer_tokens(client, sender_keypair, receiver_pubkey, mint_pubkey, amount):\n    \"\"\"Helper function to transfer tokens.\"\"\"\n    sender_ata = Token.get_associated_token_address(\n        sender_keypair.pubkey(),\n        mint_pubkey,\n    )\n    receiver_ata = Token.get_associated_token_address(\n        receiver_pubkey,\n        mint_pubkey,\n    )\n\n    transfer_ix = spl_token_instructions.transfer(\n        spl_token_instructions.TransferParams(\n            TOKEN_PROGRAM_ID,\n            sender_ata,\n            receiver_ata,\n            sender_keypair.pubkey(),\n            int(amount),\n            [sender_keypair]\n        )\n    )\n\n    return transfer_ix\n\ndef mint_nft_transaction(receiver_public_key: str):\n    \"\"\"\n    Mints a new NFT (represented as CRAFT tokens) and transfers it to the receiver.\n    This creates and returns the full transaction, ready for signing and sending.\n    \"\"\"\n    try:\n        client = Client(SOLANA_NETWORK)\n        app_keypair = Keypair.from_secret_key(base64.b64decode(APPLICATION_WALLET_PRIVATE_KEY))\n        receiver_pubkey = PublicKey(receiver_public_key)\n        craft_mint_pubkey = PublicKey(CRAFT_MINT_ADDRESS)\n        treasury_pubkey = PublicKey(TREASURY_WALLET_PUBLIC_KEY)\n\n        #Example NFT Price\n        nft_price = 10  # 10 CRAFT tokens\n        marketplace_fee_amount = int(nft_price * MARKETPLACE_FEE) #Amount taken as fee\n        seller_amount = int(nft_price - marketplace_fee_amount) #Amount to Seller\n\n        # 1. Transfer portion to Seller\n        transfer_to_seller_ix = transfer_tokens(client, app_keypair, receiver_pubkey, craft_mint_pubkey, seller_amount)\n\n        # 2. Transfer Marketplace Fee to Treasury\n        transfer_to_treasury_ix = transfer_tokens(client, app_keypair, treasury_pubkey, craft_mint_pubkey, marketplace_fee_amount)\n\n\n        # Create the transaction\n        transaction = Transaction().add(transfer_to_seller_ix, transfer_to_treasury_ix)\n        transaction.fee_payer = app_keypair.pubkey()\n        recent_blockhash = client.get_latest_blockhash().value.blockhash\n        transaction.recent_blockhash = recent_blockhash\n\n        #Sign as payer\n        transaction.sign(app_keypair)\n\n\n        #Sanity Check for validity (remove in prod, slows things down a bit)\n        #transaction.verify()\n        return transaction\n\n    except Exception as e:\n        print(f\"Error creating mint NFT transaction: {e}\")\n        return None\n\ndef send_and_confirm_transaction(transaction):\n    \"\"\"Sends and confirms a Solana transaction.\"\"\"\n    try:\n        client = Client(SOLANA_NETWORK)\n        result = client.send_transaction(transaction)\n        return result[\'result\']\n\n    except Exception as e:\n        print(f\"Error sending transaction: {e}\")\n        return None\n\ndef check_transaction_status(signature: str):\n    \"\"\"Checks the status of a Solana transaction.\"\"\"\n    try:\n        client = Client(SOLANA_NETWORK)\n        result = client.get_signature_statuses([signature])\n\n        if result and result[\'result\'] and result[\'result\'][0]:\n            confirmation_status = result[\'result\'][0][\'confirmationStatus\']\n            return confirmation_status == \'confirmed\' or confirmation_status == \'finalized\'\n        else:\n            return False\n    except Exception as e:\n        print(f\"Error checking transaction status: {e}\")\n        return False",
  "craft-nft-marketplace/backend/app/nft_generator.py": "# craft-nft-marketplace/backend/app/nft_generator.py\nimport svgwrite\nimport random\nimport hashlib\n\ndef generate_unique_nft(seed: str):\n    \"\"\"Generates a unique SVG NFT based on a seed.\n\n    Args:\n        seed: A string used to ensure uniqueness (e.g., transaction hash).\n\n    Returns:\n        A string containing the SVG data.\n    \"\"\"\n\n    random.seed(seed) #Seed the num gen so images come out consistent for download\n\n    width, height = 200, 200\n    dwg = svgwrite.Drawing(filename=\'nft.svg\', size=(width, height))\n\n    # Generate random colors\n    bg_color = f\"rgb({random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)})\"\n    circle_color = f\"rgb({random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)})\"\n    text_color = f\"rgb({random.randint(0, 255)}, {random.randint(0, 255)}, {random.randint(0, 255)})\"\n\n    # Draw background\n    dwg.add(dwg.rect(insert=(0, 0), size=(width, height), fill=bg_color))\n\n    # Draw a circle\n    circle_x = width / 2\n    circle_y = height / 2\n    circle_radius = width / 4\n    dwg.add(dwg.circle(center=(circle_x, circle_y), r=circle_radius, fill=circle_color))\n\n    # Add text with the seed\n    dwg.add(dwg.text(seed[:8], insert=(width/2 - 30, height - 20 ), fill=text_color)) #Show a bit of the seed\n\n    return dwg.tostring()",
  "craft-nft-marketplace/backend/app/email_service.py": "# craft-nft-marketplace/backend/app/email_service.py\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.mime.image import MIMEImage\nfrom .config import settings\n\ndef send_nft_email(user_email: str, nft_svg: str, nft_id: str, transaction_hash: str):\n    \"\"\"Sends an email with the NFT image and a link to the platform.\n\n    Args:\n        user_email: The recipient's email address.\n        nft_svg: The SVG data of the NFT.\n        nft_id: The ID of the NFT (transaction hash).\n        transaction_hash: The Solana transaction hash.\n    \"\"\"\n    msg = MIMEMultipart()\n    msg[\'From\'] = settings.EMAIL_FROM_ADDRESS\n    msg[\'To\'] = user_email\n    msg[\'Subject\'] = \"Your CRAFT NFT!\"\n\n    # Email body\n    body = f\"\"\"\n    <p>Congratulations! You have successfully purchased a CRAFT NFT.</p>\n    <p>Here is your NFT: <br><img src=\"cid:nft_image\"></p>\n    <p>View NFT details URL to come! </p>\n    <p>Transaction Hash: {transaction_hash} <a href=\'https://explorer.solana.com/tx/{transaction_hash}?cluster=devnet\'>View in explorer</a></p>\n    \"\"\"\n\n    msg.attach(MIMEText(body, \'html\'))\n\n    # Attach the SVG image\n    try:\n        img = MIMEImage(nft_svg.encode(\'utf-8\'), \'svg+xml\')\n        img.add_header(\'Content-ID\', \'<nft_image>\')\n        img.add_header(\'Content-Disposition\', \'inline\', filename=f\'nft-{nft_id}.svg\')\n        msg.attach(img)\n    except Exception as e:\n        print(f\"Error attaching image to email: {e}\")\n        return False\n\n    try:\n        server = smtplib.SMTP(settings.EMAIL_HOST, settings.EMAIL_PORT)\n        server.starttls()  # Upgrade connection to secure\n        server.login(settings.EMAIL_HOST_USER, settings.EMAIL_HOST_PASSWORD)\n        server.sendmail(settings.EMAIL_FROM_ADDRESS, user_email, msg.as_string())\n        server.quit()\n        return True\n    except Exception as e:\n        print(f\"Error sending email: {e}\")\n        return False",
  "craft-nft-marketplace/backend/app/api.py": "# craft-nft-marketplace/backend/app/api.py\nfrom fastapi import FastAPI, HTTPException, Depends, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom . import security\nfrom .blockchain import mint_nft_transaction, send_and_confirm_transaction\nfrom .nft_generator import generate_unique_nft\nfrom .email_service import send_nft_email\nfrom pydantic import BaseModel\nfrom fastapi import BackgroundTasks\nimport secrets\nfrom .utils import generate_keypair, validate_public_key\nfrom .tasks import send_email_task\n\napp = FastAPI()\n\norigins = [\n    \"http://localhost:3000\", # React default\n    \"http://localhost\",\n    \"http://127.0.0.1:8000\", #FastAPI may run on this one\n    \"http://127.0.0.1\",\n     # Add other origins allowed to access your API\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# --- Data Models ---\nclass User(BaseModel):\n    username: str\n    email: str\n    password: str\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass NFTMintRequest(BaseModel):\n    receiver_public_key: str\n\nclass WalletCreationResponse(BaseModel):\n    public_key: str\n    private_key: str\n\n# --- Utility Functions ---\ndef generate_strong_password() -> str:\n    \"\"\"Generates a cryptographically secure random password.\"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()\"\n    password = \'\'.join(secrets.choice(alphabet) for i in range(12)) #12 characters good enough for demo\n    return password\n\n# --- API Endpoints ---\n@app.get(\"/\")\nasync def read_root():\n    return {\"message\": \"CRAFT NFT Marketplace API\"}\n\n@app.post(\"/register\")\nasync def register_user(user: User):\n    # In a real implementation, add user to a database\n    hashed_password = security.hash_password(user.password)\n    return {\"message\": \"User registration implemented\"}\n\n@app.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    tempPass = generate_strong_password()\n    access_token = security.create_access_token(\n        data={\"sub\": form_data.username , \"password\": tempPass} #generate a strong password for demo\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me\")\nasync def read_users_me(token: str = Depends(oauth2_scheme)):\n    user = security.verify_token(token)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return user\n\n@app.post(\"/create_wallet\", response_model=WalletCreationResponse)\nasync def create_wallet(token: str = Depends(oauth2_scheme)):\n    user = security.verify_token(token)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    public_key, private_key = generate_keypair()\n    return {\"public_key\": public_key, \"private_key\": private_key}\n\n\n@app.post(\"/mint_nft\")\nasync def mint_nft(request: NFTMintRequest, background_tasks: BackgroundTasks, token: str = Depends(oauth2_scheme)):\n    \"\"\"Mints a new NFT.\n    Args:\n        request: The mint request containing the receiver's public key.\n        background_tasks: FastAPI background task manager\n        token: JWT token to verify user\n    Returns:\n        The transaction hash and NFT ID.\n    \"\"\"\n    user = security.verify_token(token)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n\n    if not validate_public_key(request.receiver_public_key):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid public key forma Backend (FastAPI): `ct\",\n        )\n    # 1. Create Mint NFT transaction\n    try:\n        transaction = mint_nft_transaction(request.receiver_public_key)\n        if not transaction:\n            raise HTTPException(status_code=500, detail=\"Failed to create transaction\")\n\n        # 2. Send and confirm transaction\n        signature = send_and_confirm_transaction(transaction)\n        if not signature:\n            raise HTTPException(status_code=500, detail=\"Transaction failed to send/confirm\")\n\n        # 3. Generate Unique NFT\n        nft_svg = generate_unique_nft(signature)\n\n        # 4. Send NFT via email through Celery\n        send_email_task.delay(user[\'sub\'], nft_svg, signature, signature) #User sub is user email!\n\n        # 5. Return the NFT details\n        return {\"transaction_hash\": signature, \"nft_svg\": nft_svg}\n\n    except Exception as e:\n        print(f\"Minting error: {e}\") #Good to see backend print in console!\n        raise HTTPException(status_code=500, detail=str(e))",
  "craft-nft-marketplace/backend/app/test_utils.py": "# craft-nft-marketplace/backend/app/tests/test_utils.py\n# Add test utility functions here\n    # Example: Generate test users to add",
  "craft-nft-marketplace/backend/tests/conftest.py": "# craft-nft-marketplace/backend/tests/conftest.py\nimport pytest",
  "craft-nft-marketplace/backend/tests/test_api.py": "# craft-nft-marketplace/backend/tests/test_api.py\nimport pytest\n# from fastapi import status\n#Write test api to check status codes for minting, logins, checking token",
  "craft-nft-marketplace/backend/tests/test_blockchain.py": "craft-nft-marketplace/backend/tests/test_blockchain.py\nimport pytest\n#Write test blockchain to check transaction details",
  "craft-nft-marketplace/backend/tests/test_nft_generator.py": "# craft-nft-marketplace/backend/tests/test_nft_generator.py\nimport pytest\nfrom app.nft_generator import generate_unique_nft\ndef test_generate_unique_nft():\n    svg = generate_unique_nft('test_nft_id') #Test example\n    assert isinstance(svg, str)\n    assert '<svg' in svg",
  "craft-nft-marketplace/backend/celeryconfig.py": "# craft-nft-marketplace/backend/celeryconfig.py\nimport os\nfrom celery.schedules import crontab\n\nbroker_url = os.environ.get('CELERY_BROKER_URL', 'redis://localhost:6379/0') #Broker local\nresult_backend = os.environ.get('CELERY_RESULT_BACKEND', 'redis://localhost:6379/0') #Result local, docker is different\n\ntask_serializer = 'json'\nresult_serializer = 'json'\naccept_content = ['json']\ntimezone = 'UTC'\nenable_utc = True\n\nbeat_schedule = {\n    'send-weekly-report': {\n        'task': 'app.tasks.send_weekly_report',\n        'schedule': crontab(day_of_week=1, hour=9, minute=0), # Executes every monday at 9:00 A.M.\n        'args': (),\n    },\n}",
  "craft-nft-marketplace/backend/app/tasks.py": "# craft-nft-marketplace/backend/app/tasks.py\nfrom celery import Celery\nfrom .email_service import send_nft_email\nfrom .config import settings\nimport os\n\ncelery = Celery('tasks', broker=os.environ.get('CELERY_BROKER_URL', 'redis://localhost:6379/0'))\ncelery.config_from_object('celeryconfig')\n\n@celery.task\ndef send_email_task(user_email: str, nft_svg: str, nft_id: str, transaction_hash: str):\n    \"\"\"Celery task to send email asynchronously.\"\"\"\n    print(f\"Sending email task for {user_email}...\")\n    return send_nft_email(user_email, nft_svg, nft_id, transaction_hash)\n\n@celery.task\ndef send_weekly_report():\n    \"\"\"Celery task to send weekly report (example).\"\"\"\n    print('report time')\n    # Logic to generate and send a weekly report\n    # This is just a placeholder, you would need to implement the actual logic\n    return 'Weekly report sent!'",
  "craft-nft-marketplace/backend/requirements.txt": "fastapi==0.109.2\nuvicorn==0.27.0\npython-jose==3.3.0\npasslib==1.7.4\npython-multipart==0.0.6\nfastapi-middleware==0.1.5\nsolana==0.28.1\npydantic==2.6.0\nemail-validator==2.1\nsqlalchemy==2.0.26\npsycopg2-binary==2.9.9\ncelery[redis]==5.3.6\nsvgwrite==1.4.3",
  "craft-nft-marketplace/backend/Dockerfile": "FROM python:3.9-slim-buster\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nCMD [\"uvicorn\", \"app.api:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]",
  "craft-nft-marketplace/backend/docker-compose.yml": "version: \"3.9\"\nservices:\n  api:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"8000:8000\"\n    environment:\n      SOLANA_NETWORK: \"http://127.0.0.1:8899\" #Change to testnet/mainnet\n      CRAFT_MINT_ADDRESS: \"YOUR_CRAFT_MINT_ADDRESS\"\n      APPLICATION_WALLET_PRIVATE_KEY: \"YOUR_APPLICATION_WALLET_PRIVATE_KEY\"\n      TREASURY_WALLET_PUBLIC_KEY: \"YOUR_TREASURY_WALLET_PUBLIC_KEY\"\n      EMAIL_HOST: \"smtp.example.com\" #Ex: smtp.gmail.com\n      EMAIL_PORT: 587\n      EMAIL_HOST_USER: \"your_email@example.com\"\n      EMAIL_HOST_PASSWORD: \"your_email_password\"\n      EMAIL_FROM_ADDRESS: \"your_email@example.com\"\n      MARKETPLACE_FEE: 0.02\n  redis:\n    image: redis:latest\n    ports:\n      - \"6379:6379\"\n\n  celery:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    command: celery -A app.tasks worker --loglevel=info\n    volumes:\n      - .:/app\n    environment:\n      CELERY_BROKER_URL: redis://redis:6379/0\n      CELERY_RESULT_BACKEND: redis://redis:6379/0\n      SOLANA_NETWORK: \"http://127.0.0.1:8899\"\n      CRAFT_MINT_ADDRESS: \"YOUR_CRAFT_MINT_ADDRESS\"\n      APPLICATION_WALLET_PRIVATE_KEY: \"YOUR_APPLICATION_WALLET_PRIVATE_KEY\"\n      TREASURY_WALLET_PUBLIC_KEY: \"YOUR_TREASURY_WALLET_PUBLIC_KEY\"\n      EMAIL_HOST: \"smtp.example.com\" #Ex: smtp.gmail.com\n      EMAIL_PORT: 587\n      EMAIL_HOST_USER: \"your_email@example.com\"\n      EMAIL_HOST_PASSWORD: \"your_email_password\"\n      EMAIL_FROM_ADDRESS: \"your_email@example.com\"\n      MARKETPLACE_FEE: 0.02\n    depends_on:\n      - api\n      - redis\n",
  "craft-nft-marketplace/deploy/docker-compose.yml": "version: \"3.9\"\nservices:\n  nginx:\n    image: nginx:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro\n    depends_on:\n      - frontend\n      - backend\n\n  frontend:\n    build:\n      context: ../frontend\n      dockerfile: Dockerfile\n    environment:\n      - REACT_APP_API_URL=/api\n\n  backend:\n    build:\n      context: ../backend\n      dockerfile: Dockerfile\n    environment:\n      SOLANA_NETWORK: \"$SOLANA_NETWORK\"\n      CRAFT_MINT_ADDRESS: \"$CRAFT_MINT_ADDRESS\"\n      APPLICATION_WALLET_PRIVATE_KEY: \"$APPLICATION_WALLET_PRIVATE_KEY\"\n      TREASURY_WALLET_PUBLIC_KEY: \"$TREASURY_WALLET_PUBLIC_KEY\"\n      EMAIL_HOST: \"$EMAIL_HOST\"\n      EMAIL_PORT: $EMAIL_PORT\n      EMAIL_HOST_USER: \"$EMAIL_HOST_USER\"\n      EMAIL_HOST_PASSWORD: \"$EMAIL_HOST_PASSWORD\"\n      EMAIL_FROM_ADDRESS: \"$EMAIL_FROM_ADDRESS\"\n      MARKETPLACE_FEE: $MARKETPLACE_FEE",
  "craft-nft-marketplace/deploy/nginx/nginx.conf": "events {}\n\nhttp {\n    upstream frontend {\n        server frontend:3000; # Assuming frontend runs on port 3000\n    }\n\n    upstream backend {\n        server backend:8000; # Assuming backend runs on port 8000\n    }\n\n    server {\n        listen 80;\n        listen 443 ssl; # Requires SSL certificate configuration\n        server_name yourdomain.com; # Replace with your domain\n\n        # SSL configuration (example - you'll need to generate/obtain real certificates)\n        # ssl_certificate /etc/nginx/ssl/yourdomain.com.crt;\n        # ssl_certificate_key /etc/nginx/ssl/yourdomain.com.key;\n\n        location / {\n            proxy_pass http://frontend;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n        }\n\n        location /api/ {\n            proxy_pass http://backend/;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            rewrite /api/(.*) /$1  break;\n        }\n    }\n}",
  "craft-nft-marketplace/frontend/.env.example": "REACT_APP_API_URL=http://localhost:8000\nREACT_APP_SOLANA_NETWORK=http://127.0.0.1:8899",
  "craft-nft-marketplace/frontend/Dockerfile": "FROM node:16-slim as builder\n\nWORKDIR /app\n\nCOPY package*.json .\nRUN npm install\n\nCOPY . .\nRUN npm run build\n\n# Production image\nFROM nginx:alpine\n\nCOPY --from=builder /app/build /usr/share/nginx/html\n\nEXPOSE 80\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]",
  "craft-nft-marketplace/frontend/README.md": "# CRAFT NFT Marketplace Frontend\n\nThis is the React frontend for the CRAFT NFT Marketplace.\n\n## Available Scripts\n\nIn the project directory, you can run:\n\n### `npm start`\n\nRuns the app in the development mode.\nOpen [http://localhost:3000](http://localhost:3000) to view it in the browser.\n\nThe page will reload if you make edits.\nYou will also see any lint errors in the console.\n\n### `npm run build`\n\nBuilds the app for production to the `build` folder.\nIt correctly bundles React in production mode and optimizes the build for the best performance.",
  "craft-nft-marketplace/frontend/package.json": "{\n  \"name\": \"craft-nft-marketplace-frontend\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"@solana/spl-token\": \"^0.3.9\",\n    \"@solana/wallet-adapter-base\": \"^0.9.23\",\n    \"@solana/wallet-adapter-phantom\": \"^0.9.24\",\n    \"@solana/wallet-adapter-react\": \"^0.15.35\",\n    \"@solana/web3.js\": \"^1.90.0\",\n    \"axios\": \"^1.6.7\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.22.1\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\"\n  \",\n  \"devDependencies\": {\n    \"eslint\": \"^8.56.0\",\n    \"eslint-plugin-react\": \"^7.34.0\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\n      \"react-app\",\n      \"react-app/jest\"\n    ]\n  },\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ],\n    \"development\": [\n      \"last 1 chrome version\",\n      \"last 1 firefox version\",\n      \"last 1 safari version\"\n    ]\n  }\n}",
  "craft